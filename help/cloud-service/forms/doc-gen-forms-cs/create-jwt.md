---
title: Creación de un token web JSON
description: Cree un token web JSON (JWT) que se pueda intercambiar con las API de Adobe IMS por un token de acceso AEM.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: Cloud Service
feature: Adaptive Forms
topic: Development
kt: 8184
thumbnail: 8184.jpg
exl-id: 394ed621-1106-4b2a-a6b7-2efa5867f5b1
source-git-commit: b069d958bbcc40c0079e87d342db6c5e53055bc7
workflow-type: tm+mt
source-wordcount: '112'
ht-degree: 0%

---

# Creación de un token web JSON

Los tokens web JSON son un método RFC 7519 abierto y estándar del sector para representar las reclamaciones de forma segura entre dos partes. Las bibliotecas JWT.io se utilizaron en esta muestra para generar el JWT.
Las credenciales de servicio que ha descargado en el paso anterior contienen la clave privada en formato PKCS#1. Para extraer la clave privada de esta cadena hemos utilizado [BouncyCastle](https://www.bouncycastle.org/) bibliotecas. Las bibliotecas criptográficas que forman parte de java no admiten el formato PKCS#1.

El siguiente código se utilizó para generar el JWT:

```java
public String getJWTToken()
    {
            Security.addProvider(new BouncyCastleProvider());
            RSAPrivateKey privateKey = null;
            GetServiceCredentials getCredentials = new GetServiceCredentials();
            try 
            {

                long now = System.currentTimeMillis();
                Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
                // get the private key string from the service credentials
                String privateKeyString = getCredentials.getPRIVATE_KEY();
              //The JWT signature algorithm we use to sign the token
                SignatureAlgorithm sa = SignatureAlgorithm.RS256;
                
                
                Reader targetReader = new StringReader(privateKeyString);
                // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
                PEMParser pemParser = new PEMParser(targetReader);
                // tores the result generated by the pEMParser
                Object object = pemParser.readObject();
                JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
                KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
                privateKey = (RSAPrivateKey) kp.getPrivate();
                
              //Let's set the JWT Claims

                Map < String, Object > jwtClaims = new HashMap < String, Object > ();
                jwtClaims.put("iss", getCredentials.getORG_ID());
                jwtClaims.put("sub", getCredentials.getTECH_ACCT());
                jwtClaims.put("exp", expirationTime);
                jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
                String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
                    
                for (String metascope: metascopes)
                {
                            jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
                }

                
                // Create the final JWT token
                String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
                    System.out.println("Got JWT Token " + jwtToken);
                    pemParser.close();
                return jwtToken;

            } catch (IOException e) {
                
                    System.out.println("The error is " + e.getMessage());
            }
            return null;

    }
```
