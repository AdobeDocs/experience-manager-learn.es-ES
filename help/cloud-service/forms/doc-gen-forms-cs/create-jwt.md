---
title: Creación de un token web JSON (JWT)
description: Cree un token web JSON (JWT) que se pueda intercambiar con las API de IMS de Adobe por un token de acceso de AEM.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: cloud-service
feature: Formularios adaptables
topic: Desarrollo
kt: 7432
thumbnail: 332439.jpg
source-git-commit: 33cb3d18b744d9a8e54a87152079b42ed09212f2
workflow-type: tm+mt
source-wordcount: '117'
ht-degree: 2%

---

# Creación de un token web JSON (JWT)


Los tokens web JSON son un método RFC 7519 abierto y estándar del sector para representar las reclamaciones de forma segura entre dos partes. Las bibliotecas JWT.io se utilizaron en esta muestra para generar el JWT.
Las credenciales de servicio que ha descargado en el paso anterior contienen la clave privada en formato PKCS#1. Para extraer la clave privada de esta cadena hemos utilizado las bibliotecas [BouncyCastle](https://www.bouncycastle.org/). Las bibliotecas criptográficas que forman parte de java no admiten el formato PKCS#1.

El siguiente código se utilizó para generar el JWT:

```java
public String getJWTToken()
	{
	        Security.addProvider(new BouncyCastleProvider());
	        RSAPrivateKey privateKey = null;
	        GetServiceCredentials getCredentials = new GetServiceCredentials();
	        try 
	        {

	            long now = System.currentTimeMillis();
	            Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
	            String privateKeyString = getCredentials.getPRIVATE_KEY();
	          //The JWT signature algorithm we will be using to sign the token
	            SignatureAlgorithm sa = SignatureAlgorithm.RS256;
	            
	            
	            Reader targetReader = new StringReader(privateKeyString);
	            // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
	            PEMParser pemParser = new PEMParser(targetReader);
	            // tores the result generated by the pEMParser
	            Object object = pemParser.readObject();
	            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
	            KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
	            privateKey = (RSAPrivateKey) kp.getPrivate();
	            
	          //Let's set the JWT Claims

	            Map < String, Object > jwtClaims = new HashMap < String, Object > ();
	            jwtClaims.put("iss", getCredentials.getORG_ID());
	            jwtClaims.put("sub", getCredentials.getTECH_ACCT());
	            jwtClaims.put("exp", expirationTime);
	            jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
	            String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
	                
	            for (String metascope: metascopes)
	            {
	                        jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
	            }

	            
	            // Create the final JWT token
	            String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
	                System.out.println("Got JWT Token " + jwtToken);
	                pemParser.close();
	            return jwtToken;

	        } catch (IOException e) {
	            
	                System.out.println("The error is " + e.getMessage());
	        }
	        return null;

	}
```
