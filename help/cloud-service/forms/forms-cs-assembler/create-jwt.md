---
title: Creación de un token web JSON (JWT)
description: AEM Cree un token web JSON (JWT) que se pueda intercambiar con las API de IMS de Adobe por un token de acceso de.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: Cloud Service
feature: Adaptive Forms
topic: Development
jira: KT-9980
exl-id: 0e3e186b-9fbe-40ad-a6cc-bdbf58b23009
duration: 52
source-git-commit: f4c621f3a9caa8c2c64b8323312343fe421a5aee
workflow-type: tm+mt
source-wordcount: '114'
ht-degree: 0%

---

# Creación de un token web JSON (JWT)

Los tokens web JSON son un método abierto y estándar en la industria RFC 7519 para representar reclamaciones de forma segura entre dos partes. En este ejemplo se utilizaron bibliotecas JWT.io para generar el JWT.
Las credenciales del servicio que descargó en el paso anterior contienen la clave privada en formato PKCS#1. Para extraer la clave privada de esta cadena, hemos utilizado [BouncyCastle](https://www.bouncycastle.org/) bibliotecas. Las bibliotecas criptográficas que forman parte de java no admiten el formato PKCS#1.

El siguiente código se utilizó para generar el JWT:

```java
public String getJWTToken()
    {
            Security.addProvider(new BouncyCastleProvider());
            RSAPrivateKey privateKey = null;
            GetServiceCredentials getCredentials = new GetServiceCredentials();
            try 
            {

                long now = System.currentTimeMillis();
                Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
                // get the private key string from the service credentials
                String privateKeyString = getCredentials.getPRIVATE_KEY();
                //The JWT signature algorithm we use to sign the token
                SignatureAlgorithm sa = SignatureAlgorithm.RS256;
                
                
                Reader targetReader = new StringReader(privateKeyString);
                // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
                PEMParser pemParser = new PEMParser(targetReader);
                // tores the result generated by the pEMParser
                Object object = pemParser.readObject();
                JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
                KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
                privateKey = (RSAPrivateKey) kp.getPrivate();
                
              //Let's set the JWT Claims

                Map < String, Object > jwtClaims = new HashMap < String, Object > ();
                jwtClaims.put("iss", getCredentials.getORG_ID());
                jwtClaims.put("sub", getCredentials.getTECH_ACCT());
                jwtClaims.put("exp", expirationTime);
                jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
                String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
                    
                for (String metascope: metascopes)
                {
                            jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
                }

                
                // Create the final JWT token
                String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
                    System.out.println("Got JWT Token " + jwtToken);
                    pemParser.close();
                return jwtToken;

            } catch (IOException e) {
                
                    System.out.println("The error is " + e.getMessage());
            }
            return null;

    }
```
